<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-01-29 Wed 14:21 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Computer Science For The Busy Developer</title>
<meta name="generator" content="Org mode" />
<link rel="stylesheet" type="text/css" href="assets/style.css" />
<link href="//fonts.googleapis.com/css?family=Open+Sans:300,400,600,700" rel="stylesheet" type="text/css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<div id="outline-container-orgda6e3a5" class="outline-2">
<h2 id="orgda6e3a5"><span class="section-number-2">1</span> Euclid's algorithm</h2>
<div class="outline-text-2" id="text-1">
<p>
Let's start with the famous, ancient algorithm for finding the greatest common divisor (GCD) of two numbers. GCD is the largest number that divides both given numbers without leaving a remained. For example, GCD of 4 and 8 is 2.
</p>

<p>
Unless you know about Euclid's algorithm, stop and think for a while — how would you find a GCD of two numbers? What generic approach might work for any case (not taking efficiency into account at the moment)?
</p>

<p>
Right off the bat, one could suggest just trying all the numbers from the largest-minus-one down to 1. That's certainly a fine way, and considering the enormous power of modern computers, will take a fraction of a second for even large-ish numbers. Euclid, of course, was trying to solve this about 2300 years before modern computers. Trying out all the numbers manually is the last resort for any computational task. Although, if you can prove that the only way to solve the problem at hand is by brute force, then that's a good result. Some problems are fundamentally hard, for example, finding an element in an unsorted collection: there is just no way to optimize anything, you have to check all the elements (in the general case).
</p>

<p>
The Euclid's algorithm is a series of simple computations. Let's say we want to find the GCD of two numbers \(a = 47, b = 831\). The first step is to divide the larger number by the smaller and find the remainder:
</p>

<p>
\[831 = q_{0} \times 47 + r_{0}\]
\[831 = 17 \times 47 + 32\]
</p>

<p>
These new numbers \(q_{0}\) and \(r_{0}\) are called <i>quotient</i> and <i>remainder</i>. Next, we repeat the process, this time using the new numbers:
</p>

<p>
\[47 = q_{1} \times 32 + r_{1}\]
\[47 = 1 \times 32 + 15\]
</p>

<p>
And again:
</p>

<p>
\[32 = q_{2} \times 15 + r_{2}\]
\[32 = 2 \times 15 + 2\]
</p>

<p>
And again:
</p>

<p>
\[15 = q_{3} \times 2 + r_{3}\]
\[15 = 7 \times 2 + 1\]
</p>

<p>
And finally, we reach the remainder = \(0\):
</p>

<p>
\[7 = q_{4} \times 1 + r_{4}\]
\[7 = 7 \times 1 + 0\]
</p>

<p>
This series is guaranteed to end with a zero remainder, and the last non-zero remainder is the greatest common divisor (we won't provide a proof here for either statements). In our example, \(GCD(47, 831) = 1\).
</p>

<hr />

<p>
This is a proper algorithm because:
</p>
<ul class="org-ul">
<li>It is formal and unambiguous. There is no room for interpretation or assumption.</li>
<li>It can be proved to we correct.</li>
<li>It can be analyzed, best and worst case scenarios can be determined for the general case.</li>
</ul>

<p>
These are kind of properties we want from algorithms.
</p>

<p>
Let's implement this algorithm in Python.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #a626a4;">def</span> <span style="color: #0184bc;">gcd</span>(a, b):
  <span style="color: #a626a4;">while</span> b != 0:
    <span style="color: #8b4513;">t</span> = b
    <span style="color: #8b4513;">b</span> = a % b
    <span style="color: #8b4513;">a</span> = t
  <span style="color: #a626a4;">return</span> a
</pre>
</div>

<p>
This is a recursive approach, which is a natural idea under given circumstances, since each step of the Euclid's algorithm is the same, only the numbers "shift". The stopping condition is <code>b != 0</code>, and until it's reached we use <code>t</code> as a temporary variable while computing new value for <code>b</code>. Recall that <code>%</code> is a modulo operator which returns the remainder after division — exactly what we need for \(d_{k}\) at each step \(k\).
</p>
</div>
</div>
</div>
</body>
</html>
