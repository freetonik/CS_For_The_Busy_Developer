<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-02-05 Wed 13:31 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Computer Science For The Busy Developer</title>
<meta name="generator" content="Org mode" />
<link rel="stylesheet" type="text/css" href="assets/style.css" />
<link href="//fonts.googleapis.com/css?family=Open+Sans:300,400,600,700" rel="stylesheet" type="text/css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<div id="outline-container-org17da48b" class="outline-2">
<h2 id="org17da48b"><span class="section-number-2">1</span> Why sort? Faithsort and Bogosort</h2>
<div class="outline-text-2" id="text-1">
<p>
Sorting is the staple of computer science education. We all have to deal with sorting one way or another: in college, in textbooks or during job interviews. We also occasionally sort things in real life: books on the shelf by author or, perhaps, by color; tasks in our ToDo lists by importance or priority, etc. Yet, I don't think I had implemented a sorting algorithm in a professional setting, ever. And I can imagine only a small subset of programmers who think deeply about sorting and implement new or modified sorting algorithms as part of their job.
</p>

<p>
The reason people give sorting this much attention is twofold:
</p>

<ol class="org-ol">
<li>It is a truly important kind of problem in computer science.</li>
<li>Understanding and implementing sorting algorithms is a good exercise for computational thinking.</li>
</ol>

<p>
Let's take an example collection of numbers <code>[3, 8, 1, 2, 5, 6, 4, 7, 9]</code> and see what approaches we can take.
</p>

<p>
What is the dumbest sorting algorithm possible? One idea is to check whether the collection is sorted, and if not, just wait and check again later. Of course, it will never be sorted. Or will it? Maybe with enough time in an infinite universe, bits could spontaneously flip due to quantum effects. Or, if we're talking on a more practical level, the electronic representation of said bits (computer memory) could be affected by cosmic rays, radiation or just plain data corruption. As a result, the possibility of the collection becoming sorted by accident is non-zero.
</p>

<p>
Let's call it "faithsort":
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #a626a4;">def</span> <span style="color: #0184bc;">faithsort</span>(collection):
    <span style="color: #a626a4;">while</span> <span style="color: #a626a4;">not</span> is_sorted(collection):
        time.sleep(random.random())
    <span style="color: #a626a4;">return</span> collection
</pre>
</div>

<p>
How long would it take to successfully finish?
</p>

<ol class="org-ol">
<li>Best case: collection is empty or already sorted. Time needed: effectively 0.</li>
<li>Average case: collection becomes sorted after some time. Time needed: unknown, but finite.</li>
<li>Worst case: collection is never sorted. Time needed: n/a.</li>
</ol>

<p>
Alright, jokes aside, what is the dumbest but still practical sorting algorithm possible? It's probably bogosort: shuffle the collection until it's sorted:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #a626a4;">def</span> <span style="color: #0184bc;">bogosort</span>(collection):
    <span style="color: #a626a4;">while</span> <span style="color: #a626a4;">not</span> is_sorted(collection):
        random.shuffle(collection)
    <span style="color: #a626a4;">return</span> collection
</pre>
</div>

<p>
How long would it take to successfully finish?
</p>

<ol class="org-ol">
<li>Best case: collection is empty or already sorted. Time needed: effectively 0.</li>
<li>Average case: collection becomes sorted after some shuffling. Time needed: unknown, but finite.</li>
<li>Worst case: collection is never sorted. Time needed: n/a.</li>
</ol>

<p>
You can say that both faithsort and bogosort are equally useless, but it looks like with bogosort it's at least not inconceivable to expect the correct result in our lifetime. In fact, for our collection <code>[3, 8, 1, 2, 5, 6, 4, 7, 9]</code>, the Python program presented above was successful on average with ≈100000 permutations and took about 2-5 seconds on a modern laptop.
</p>

<p>
Both algorithms are bad not because they are slow, but mainly because they are <b>unbounded</b>: their worst case is infinity. This means we can't ever rely on the program to terminate (finish executing).
</p>

<hr />

<p>
Consider a slightly better version: deterministic bogosort. In this version, the shuffling is not completely random, but instead it iterates through all possible permutations. The amount of permutations is finite if the collection is finite.
</p>

<p>
How to determine the number of permutations of \(n\) items? An intuitive explanation is rather simple. Consider nine elements <code>1, 2, 3, 4, 5, 6, 7, 8, 9</code>. Now, try to construct one permutation.
</p>

<ol class="org-ol">
<li>You need to choose the first element for it. There are 9 to choose from, so you have 9 choices.</li>
<li>Next, you need to chose the second element. There are 8 left to choose from.</li>
<li>Next, third element. 7 left to choose from.</li>
<li>Etc.</li>
</ol>

<p>
So, the total number of permutations is \(9\times8\times7\times6\times5\times4\times3\times2\times1\) which is \(9!\) Thus, for \(n\) items, there are \(n!\) permutations.
</p>

<p>
Our deterministic bogosort does two things for each iteration: checks whether the collection is sorted and, if needed, shuffles it. We know there are at least \(n!\) permutations to shuffle through, so now we have to find out how much more work needs to happen for each permutation. This work is hidden in the checking (<code>is_sorted(collection)</code>). How much work?
</p>

<p>
(Note: of course, the deterministic shuffling itself is a non-trivial task that would also require some work and contribute to the total number of operations. For simplicity, we're ignoring this part.)
</p>

<p>
Again, consider collection <code>1, 2, 3, 4, 5, 6, 7, 8, 9</code>. In order to determine whether it's sorted or not, you have to go through all the items and check that they're placed in increasing order. Best case is something like <code>9, 1, 2, 3, 4, 5, 6, 7, 8</code>: the first check immediately yields "not sorted". Worst case is something like <code>2, 3, 4, 5, 6, 7, 8, 9, 1</code>: you have to iterate through all the items and only at the last step it turns out the collection is not sorted.
</p>

<p>
So, worst case is \(n-1\) checks for the collection of \(n\) elements. If you want to go deeper, you can calculate the exact number of operations according to the RAM model: comparing a pair means accessing two elements (\(2\)), running a comparison operator (\(1\)), reading, increasing and writing the loop counter (\(1 + 1 + 1\)), etc. But, as you probably already noticed, we're not interested in accuracy as much as in scale. We can safely say it requires about \(n\) operations to check for sortedness, and ignore whatever constant multiplier there could be (like \(19 \times n\) — we don't care about 19, it's a constant number which never grows with \(n\)).
</p>

<p>
So, in total, deterministic bogosort requires \(n \times n!\) operations. This is its upper bound. Now the cases are as follows:
</p>

<ol class="org-ol">
<li>Best case: collection is empty or already sorted. Time needed: effectively \(0\).</li>
<li>Average case: collection becomes sorted after some shuffling. Time needed: unknown, but finite.</li>
<li>Worst case: collection becomes sorted after maximum possible amount of shuffling. Time needed: \(n \times n!\)</li>
</ol>

<p>
Now it's bounded! Great!
</p>
</div>
</div>
</div>
</body>
</html>
